<h2 id="tldr">tl;dr</h2>
<p>You may find it useful to consider this list of factors when deciding between several JavaScript MV* frameworks. We’re not going to lecture you about which solution you should choose – we’ll leave that up to you.</p>

<h2 id="the-problem">The problem</h2>
<p>There are lots of JavaScript MV* frameworks to choose from. They don’t all have exactly the same goals and several of them subscribe to fundamentally different design principles.</p>

<p>Conducting a realistic trial of just a few of them is a substantial exercise; without building something moderately complicated, it is difficult to get past the introductory material and really get a feel for a framework. Plus, a lot of the tutorials omit any coverage of testing - presumably to reduce cognitive load on those looking for a basic introduction. Of course, there is TodoMVC, which is a fantastic resource, but comparing pre-made examples only answers some of the questions you need to work through to make an informed choice.</p>

<h2 id="what-do-you-need-to-think-about-when-choosing">What do you need to think about when choosing?</h2>
<p>There is no magic solution for this problem. But, having evaluated several frameworks ourselves, we wanted to share the list of differentiating factors we feel are important. We hope they will be useful for you too.</p>

<h3 id="magic">1) Magic</h3>
<p>A common design goal among the available frameworks is to allow the developer to do more with less. To us, it appears this results in a trade-off between:</p>

<ul>
  <li>Completely transparent/explicit code – clarity with the cost of being more verbose, and</li>
  <li>Convention over configuration – more power with less code, but in some cases can appear rather magical to the unfamiliar user</li>
</ul>

<p>Some frameworks, <a href="http://backbonejs.org">Backbone</a> for example, achieve the goal simply by providing you a structure to work in; so you can focus more on the what rather than the how. At the other end of the scale, there are frameworks such as <a href="http://emberjs.com/">Ember</a>; you work to its conventions and in return it will do a lot for you without you needing to ask.</p>

<p>Some questions to think about:</p>

<ol>
  <li>Who will be the future maintainer of the application? Will they be familiar with your chosen framework?</li>
  <li>What productivity features do you want? E.g. do you want to use 2-way data binding? Are you happy for the framework to automatically create objects in the background unless you want to customise them?</li>
  <li>Do you prefer code to be as transparent and explicit as possibly at the cost of it being more verbose? Or are you happy to conform with conventions in order to do more with less code?</li>
  <li>Are you planning on specialising in the framework and/or investing in training your team?</li>
</ol>

<p>We stumbled upon a handy litmus test for this quality: run through a practical intro-tutorial for each of the technologies on your short list, then come back a week later and re-read the code. Can you explain with confidence how it works and how long does it take you to understand it again?</p>

<h3 id="routing">2) Routing</h3>
<p>A key feature of single page applications is the ability to present several screens to the user without needing to completely reload the page each time.</p>

<p>Several of the available frameworks provide a convenient implementation of this by adapting the URL-routing concept, borrowed from server-side frameworks such as <a href="http://guides.rubyonrails.org/routing.html">Rails</a>, for use with the <a href="http://en.wikipedia.org/wiki/Fragment_identifier">URL fragment</a>. Others provide no such support, which means you would need to either parse window.location yourself or look for a plugin.</p>

<p>Key questions:</p>

<ol>
  <li>Is your application transferring enough data on each full page load that making it a single-page app would bring significant benefits? E.g. more responsiveness in terms of latency or reduced data transfer costs.</li>
  <li>If you decide to use a single-page architecture, do your users need the ability to share links to sub-screens within the interface? If so look for a framework that routes based on the URL.</li>
  <li>Does the framework have built-in support for routing?</li>
  <li>Does the framework support routing as an add-on (e.g. <a href="https://angularjs.org/">Angular</a>)?</li>
</ol>

<h3 id="templating">3) Templating</h3>
<p>Some frameworks have been built to use a specific templating technology exclusively, others allow a free choice. Tighter integration with a specific framework is possibly about enabling more interesting features e.g. 2-way-data binding and custom components, but this comes at the cost of choice.</p>

<p>Some favour, or at least enable, embedding markup within the JavaScript code (<a href="http://facebook.github.io/react/">React</a> for example).</p>

<p>Key questions:</p>

<ol>
  <li>Do you prefer to use templates or embed HTML markup within your JavaScript code?
2.Does the framework under consideration force you to use a specific templating solution or are you free to use any of your choice? If the former is true, are there enough advantages that it’s worth putting up with it?</li>
</ol>

<h3 id="dependencies">4) Dependencies</h3>
<p>Does the framework depend on any 3rd party libraries (e.g. <a href="http://jquery.com/">jQuery</a>)? If so, does this present a conflict with any libraries you want to use (e.g. <a href="http://zeptojs.com/">Zepto</a>) or force you to use specific versions?</p>

<h3 id="module-loaders">5) Module Loaders</h3>
<p>If you are using an <a href="http://requirejs.org/docs/whyamd.html">AMD module loader</a>, such as <a href="http://requirejs.org/">RequireJS</a>, is the framework compatible with it?</p>

<p>For example, the Ember team are not convinced by the AMD approach to module loading, which may or may not mean that the two will work well together. Angular has its own built-in solution for modularity and dependency resolution, but can still be used with an AMD style loader if desired.</p>

<h3 id="testability">6) Testability</h3>
<p>How easy is it to test the code you produce within the framework?</p>

<p>Key questions:</p>

<ol>
  <li>Do you need to do a lot of complicated set-up to isolate the unit you want to test?</li>
  <li>Is it obvious how to get at and test the features of the unit under test? Or do you need to learn a new API?</li>
  <li>Are you locked into using certain test frameworks? Or at least, if there is a recommended framework, what are the costs/obstacles likely to be if you try to use an alternative? E.g. choosing to test an Ember app with Mocha instead of QUnit.</li>
  <li>Is it easy to write end-to-end system tests (using Karma or similar)?</li>
</ol>

<h3 id="remote-api-integration">7) Remote API Integration</h3>
<p>For basic AJAX calls most of the frameworks either provide an HTTP client service or you can choose your own, e.g. jQuery.getJSON or similar.</p>

<p>The majority also provide some sort of convenient model abstraction. Where the details of the underlying persistence method – which may be a REST API or browser local storage – are hidden. So you only have to manipulate JavaScript objects.</p>

<p>We discovered an important gotcha here for REST API integration: each of the frameworks we reviewed assumed slightly different JSON response schemas. So unless you can tailor your remote API responses you may have to do extra work to plug the framework into your API.</p>

<p>You must also consider caching and synchronisation of any data you load from the server. Particularly if you have multiple users editing data concurrently.</p>

<p>Key questions:</p>

<ol>
  <li>Does the framework provide its own HTTP client service or do you have to choose your own?</li>
  <li>Does the framework support a model abstraction with REST integration? If so, what schema does it expect the JSON replies to use?</li>
  <li>Do you have control over the design of the external API or will you have to write adaptors? If the latter, how does the framework support custom API adapters?</li>
  <li>Will multiple users be able to edit your application data? If so, how and when should shared data get reloaded from the server? Will it be cached by the framework or explicitly by your own code? When will the cache be invalidated and resynced with the server?</li>
</ol>

<h3 id="documentation">8) Documentation</h3>
<p>Good documentation is crucial. Incomplete or incorrect reference material can make developing with a new technology feel a lot like marching through mud.</p>

<p>Key questions:</p>

<ol>
  <li>Is the available documentation up to date?</li>
  <li>For frameworks with unstable APIs (e.g. Ember-Data at the time of writing), is the documentation clearly linked to software release version?</li>
  <li>Is it easy to retrieve documentation for previous releases? The framework may advance quickly, but it may be difficult for you to upgrade if you’ve written a sizeable portion of your application already.</li>
  <li>Does the reference material contain relevant examples for both typical and advanced use-cases?</li>
  <li>Is there a good mix of material e.g. articles, tutorials, videos, developer guides, API references?</li>
  <li>Is there a healthy community discussing / supporting / writing about it?</li>
</ol>

<h3 id="browser-compatibility">9) Browser Compatibility</h3>
<p>MV* frameworks tend to be forward-looking. If your users are likely to be using anything but the latest browsers, then care should be taken to check the minimum versions supported. E.g. AngularJS 1.3 dropped support for IE8. So those of you with user-bases still tied to IE6 – we all know they’re out there – maybe out of luck.</p>

<p>Key questions:</p>

<ol>
  <li>What are the minimum browser versions supported by the framework and how to they compare with the versions you need for your project?</li>
  <li>Will you be able to gracefully degrade certain features in order to support less capable browsers?</li>
</ol>

<h2 id="summary">Summary</h2>
<p>So, lots of things to think about and this is by no means an exhaustive list. Depending on the constraints you are working to, you may need to consider other qualities such as rendering performance or download size. Nevertheless, we hope this list serves as a good introduction to the basic issues worth thinking about.</p>

<p>If you’d like to suggest something that we should include, then we’d love to hear from you.</p>

<p>Further Reading</p>

<p><a href="http://todomvc.com/">TodoMVC</a></p>

<p><a href="http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/">Journey Through The JavaScript MVC Jungle</a></p>

<p><a href="http://blog.codeschool.com/post/85819292538/angular-backbone-or-ember-which-is-best-for-your">Code School Blog – Angular, Backbone, or Ember: Which is Best for your Build?</a></p>
