<p>During this month’s <a href="http://www.scotrug.org">Scottish Ruby User Group</a> meeting we paired up read some code. We chose the <a href="https://github.com/ruby/ruby/blob/trunk/lib/ostruct.rb">source for <code>OpenStruct</code></a> as it was small and self-contained enough to get through in the hour or so available.</p>

<p>I expected it to be dull, but it was great fun and we all learnt a lot, mostly about stuff I should have known about Ruby, but had missed or forgotten. Here’s some highlights:-</p>

<h2 id="openstruct-implementation"><code>OpenStruct</code> implementation</h2>

<p>First let’s quickly revise what on what an <code>OpenStruct</code> does. From the documentation:</p>

<blockquote>
  <p>An <code>OpenStruct</code> is a data structure, similar to a Hash, that allows the definition of arbitrary attributes with their accompanying values. This is accomplished by using Ruby’s metaprogramming to define methods on the class itself.</p>
</blockquote>

<p>So you can do the following:-</p>

<p>```
require ‘ostruct’</p>

<p>o = OpenStruct.new
o.name = “Mavis” # arbitrarily create an attribute (name) and assign a value
puts o.name
```</p>

<p>While <code>OpenStruct</code> is similar to Hash, it isn’t a Hash; it does not extend Hash (or include Enumerable). The attributes are stored in a Hash member variable (<code>@table</code>) (see  <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L87-88">the initialize method</a>). New attributes are captured using <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L176-191"><code>method_messing</code></a> and the accessors are <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L166-173">defined as methods</a> on the object.</p>

<h2 id="freezing-an-openstruct">Freezing an <code>OpenStruct</code></h2>

<p>Freezing a Ruby object is supposed to prevent modifications. By default, this is achieved by disallowing assignment to instance variables. As the <code>OpenStruct</code>s attributes are stored within a Hash that is assigned on initialisation(<code>@table</code>), then this alone would not prevent assigning values to an <code>OpenStruct</code>; while the <code>OpenStruct</code> would be frozen, <code>@table</code> would not be.</p>

<p><code>OpenStruct</code> prevents assigning to frozen objects by all write operations accessing <code>@table</code> through the method <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L151-159">modifiable</a>.</p>

<p>```
def modifiable
  begin
    @modifiable = true
  rescue
    raise RuntimeError,
      “can’t modify frozen #{self.class}”, caller(3)
  end
  @table
end</p>

<p>protected :modifiable
```</p>

<p>Assigning a value to @modifiable will raise an error, if the object has been frozen.</p>

<p>Another way of ensuring an <code>OpenStruct</code> is properly frozen might be to override the freeze method.</p>

<p><code>
#NOT COPIED FROM ostruct.rb
def freeze
  @table.freeze
  super
end
</code></p>

<p>My guess is that this method was not followed as it would have made it harder to control the error message and stack; the error would be “can’t modify frozen Hash”, not “can’t modify frozen OpenStruct”.</p>

<h2 id="massaging-the-backtrace">Massaging the backtrace</h2>

<p>When errors are raised (in <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L155">modifiable</a> and <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L181">method</a><code>_</code><a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L187-189">missing</a>) the backtrace is modified to start at the offending piece of client code. I like this - that’s where the debugging programmer needs to look to work out a fix, not in the middle of the library code which has had its contract violated.</p>

<h2 id="definesingletonmethod"><code>define_singleton_method</code></h2>

<p><a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-define_singleton_method"><code>define_singleton_method</code></a> is method on Object that was introduced in Ruby 1.9, but had passed all us ScotRUG members by. It does what it says - defines a method on an object’s singleton class: that is it defines a method on an object instance without affecting other instances of its class. Prior to 1.9, the method would need to be retrieved - messy business.</p>

<p>This is the <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L169-170">current</a> way <code>OpenStruct</code> dynamically defines methods:-</p>

<p><code>
define_singleton_method(name) { @table[name] }
define_singleton_method("#{name}=") { |x| modifiable[name] = x }
</code></p>

<p>The <a href="https://github.com/ruby/ruby/blob/v1_8_7_17/lib/ostruct.rb#L73-75">1.8.7</a> way is a little less readable:-</p>

<p><code>
meta = class &lt;&lt; self; self; end
meta.send(:define_method, name) { @table[name] }
meta.send(:define_method, :"#{name}=") { |x| @table[name] = x }
</code></p>

<h2 id="singletonclass"><code>singleton_class</code></h2>

<p>There’s no opposite of <code>define_singleton_method</code>;  <code>remove_singleton_method</code> isn’t a thing. So, <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L223-226"><code>delete_field</code></a> finds itself dealing directly with the object’s singleton class.</p>

<p><code>
def delete_field(name)
  sym = name.to_sym
  singleton_class.__send__(:remove_method, sym,
    "#{sym}=")
  @table.delete sym
end
</code></p>

<p><a href="http://www.ruby-doc.org/core-1.9.2/Object.html#method-i-singleton_class"><code>singleton_class</code></a> was introduced in 1.9.2 to be used in place of</p>

<p><code>
(class &lt;&lt; self; self; end)
</code></p>

<p><a href="https://www.ruby-forum.com/topic/177294">This</a> is the feature request thread for <code>singleton_class</code>.</p>

<h2 id="id2name">id2name</h2>

<p>In <code>method_missing</code> <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L177">we found</a>:-</p>

<p><code>
  def method_missing(mid, *args) # :nodoc:
    mname = mid.id2name
</code></p>

<p>I have never seen <code>id2name</code> before. It is a method on Symbol that <a href="http://ruby-doc.com/docs/ProgrammingRuby/html/ref_c_symbol.html#Symbol.id2name">returns the string corresponding to the symbol</a>. I’ve always used <code>to_s</code> for that, which apparently is a <a href="http://ruby-doc.com/docs/ProgrammingRuby/html/ref_c_symbol.html#Symbol.to_s">synonym for <code>id2name</code></a>.</p>

<p>¯\<em>(ツ)</em>/¯</p>

<h2 id="toenum"><code>to_enum</code></h2>

<p>Being a bit like a Hash, <code>OpenStruct</code> provides the <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L127-130"><code>each_pair</code></a> method for iterating over the key-value pairs:-</p>

<p><code>
def each_pair
  return to_enum(__method__) { @table.size }
    unless block_given?
  @table.each_pair{|p| yield p}
end
</code></p>

<p>Delegating to the <code>@table</code> <code>Hash</code> is straightforward enough. Using <code>to_enum</code> to return an enumerator needed a bit more reading.</p>

<p><code>to_enum</code> is defined on object and <a href="http://ruby-doc.org/core-2.1.2/Object.html#method-i-to_enum">creates a new enumerator, by calling the passed-in method</a>. So by getting an enumerator from <code>each_pair</code>, here’s what happens:-</p>

<ol>
  <li>Call <code>each_pair</code> without a block</li>
  <li><code>to_enum</code> on the instance is called passing in <code>each_pair</code> as the <code>method_name</code>.</li>
  <li>This time a block will be passed in, allowing the iteration (delegated to <code>@table</code>)</li>
</ol>

<p>The number of attributes stored (<code>@table.size</code>) is given to <code>to_enum</code> as the return value of a block, because that’s how it is optionally done.</p>

<p>Using the return value of a block to get an optional value is a bit unusual. <code>to_enum</code> uses this, as it already has optional values in its method signature - arguments to pass to the method that takes the block.</p>

<h2 id="initializecopy"><code>initialize_copy</code></h2>

<p>This is a private method on Object which is called when <code>dup</code> or <code>clone</code> are used to create a copy (or clone). See <a href="http://www.jonathanleighton.com/articles/2011/initialize_clone-initialize_dup-and-initialize_copy-in-ruby/">Jon Leighton’s blog post</a>.</p>

<p><code>
def initialize_copy(orig)
  super
  @table = @table.dup
  @table.each_key{|key| new_ostruct_member(key)}
end
</code></p>

<p><code>OpenStruct</code> overrides this <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L99-103"><code>initialize_copy</code></a> to ensure that a copied object, gets a duplicate version of the <code>@table</code> <code>Hash</code> holding the key value pairs; otherwise the copy would share that data store, which would get weird. It also ensures that the dynamic methods are defined on the new copy; copy (unlike clone) does not duplicate the singleton class, so they would otherwise be missing.</p>

<h2 id="protected-members">protected members</h2>

<p>I don’t see the <code>protected</code> keyword used much in application ruby code. I think being able to override encapsulation with <code>send</code> has made us a bit lazy. Allowing the <code>@table</code> data store to be read through a protected accessor, means it can be accessed by other <code>OpenStruct</code> instances when checking equality.</p>

<p>```
attr_reader :table # :nodoc:
protected :table</p>

<p>def ==(other)
  return false unless other.kind_of?(OpenStruct)
  @table == other.table
end
```</p>

<h2 id="inspect"><code>inspect</code></h2>

<p>Inspect shows the contents of the <code>OpenStruct</code> in “key=value” form, where <code>inspect</code> is called on each of the values. Straightforward?  You would think so, but here’s <a href="https://github.com/ruby/ruby/blob/v2_1_2/lib/ostruct.rb#L234-254">the implementation</a>:</p>

<p>```
InspectKey = :<strong>inspect_key</strong> # :nodoc:
def inspect
  str = “#&lt;#{self.class}”</p>

<p>ids = (Thread.current[InspectKey] ||= [])
  if ids.include?(object_id)
    return str « ’ …&gt;’
  end</p>

<p>ids « object_id
  begin
    first = true
    for k,v in @table
      str « ”,” unless first
      first = false
      str « ” #{k}=#{v.inspect}”
    end
    return str « ’&gt;’
  ensure
    ids.pop
  end
end
```</p>

<p>The thread current storage is a bit confusing at first. It’s purpose is to guard against infinite recursion, if an <code>OpenStruct</code> instance is stored in itself.</p>

<p><code>
&gt;&gt; o = OpenStruct.new
=&gt; #&lt;OpenStruct&gt;
&gt;&gt; o.o=o
=&gt; #&lt;OpenStruct o=#&lt;OpenStruct ...&gt;&gt;
&gt;&gt;
</code></p>

<p>The object ids of all the <code>OpenStruct</code>s currently being inspected are stored in the Thread.current, to ensure that they are only inspected once.</p>

<p><code>
if ids.include?(object_id)
    return str &lt;&lt; ' ...&gt;'
end
</code></p>

<p>Evan Phoenix suggested that we should read code, in <a href="http://programme2014.scottishrubyconference.com/slots/3/video">his keynote</a> at this year’s Scottish Ruby Conference. Picking apart some well-written code is a great way to pick up on all the things you should know, but have somehow missed or forgotten.</p>
