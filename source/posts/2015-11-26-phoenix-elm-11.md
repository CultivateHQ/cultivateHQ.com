---
title: Phoenix with Elm - part 11
author: Alan Gardner
description: Introducing Phoenix channels
---

<section class="callout">
  I gave [a talk at ElixirConf 2015](http://confreaks.tv/videos/elixirconf2015-phoenix-with-elm) on combining the [Phoenix web framework](http://www.phoenixframework.org/) with the [Elm programming language](http://elm-lang.org). This is the tutorial that was referred to in that talk.

  The tutorial walks through the creation of a very basic seat saving application, like one you'd use when booking a flight for example. The application will do just enough to demonstrate the mechanisms for getting the two technologies talking to each other.

  There is an [accompanying repo](https://github.com/CultivateHQ/seat_saver) for this tutorial. Each of the numbered steps has an associated commit so that you can just look at the diffs if you'd rather not read through the whole thing.
</section>

## Notes

### Joining a channel

1. `mix phoenix.gen.channel Seat seats`
2. Update *web/channels/user_socket.ex*

    ```elixir
    defmodule SeatSaver.UserSocket do
      use Phoenix.Socket

      ## Channels
      # channel "rooms:*", SeatSaver.RoomChannel
      channel "seats:planner", SeatSaver.SeatChannel

      ...
    end
    ```

3. Update *web/channels/seat_channel.ex*

    ```elixir
    defmodule SeatSaver.SeatChannel do
      use SeatSaver.Web, :channel

      def join("seats:planner", payload, socket) do
        ...
      end

      ...
    end
    ```

4. Update *test/channels/seat_channel_test.exs*

    ```elixir
    defmodule SeatSaver.SeatChannelTest do
      ...

      setup do
        {:ok, _, socket} =
          socket("user_id", %{some: :assign})
          |> subscribe_and_join(SeatChannel, "seats:planner")

       ...
      end

      ...

      test "shout broadcasts to seats:planner", %{socket: socket} do
        ...
      end

      ...
    end
    ```

5. `mix test`
6. Update *web/static/js/socket.js*

    ```javascript
    ...

    socket.connect()

    // Now that you are connected, you can join channels with a topic:
    let channel = socket.channel("seats:planner", {})

    ...
    ```

7. Update *web/static/js/app.js*

    ```javascript
    import socket from "./socket"
    ```

8. Visit <http://localhost:4000> and check the console.

    ![Channel connected](/images/phoenix-elm/15.png)

### Getting initial seat data

1. Now we need to add some seat data. We can use the *priv/repo/seeds.exs* file same as we did in [part 9](/posts/phoenix-elm-9). Add the following to the end of that file (note that the first two seats are occupied but the rest are not):

    ```elixir
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 1, occupied: true})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 2, occupied: true})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 3, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 4, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 5, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 6, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 7, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 8, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 9, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 10, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 11, occupied: false})
    SeatSaver.Repo.insert!(%SeatSaver.Seat{seat_no: 12, occupied: false})
    ```

2. Run `mix run priv/repo/seeds.exs` to apply the seeds.
3. Add the following to the bottom of your *web/models/seat.ex* file

    ```elixir
    defimpl Poison.Encoder, for: SeatSaver.Seat do
      def encode(model, opts) do
        %{id: model.id,
          seatNo: model.seat_no,
          occupied: model.occupied} |> Poison.Encoder.encode(opts)
      end
    end
    ```

4. Now change the `join` function in the *web/channels/seat_channel.ex* file to the following:

    ```elixir
    def join("seats:planner", payload, socket) do
      if authorized?(payload) do
        send self(), :after_join
        {:ok, socket}
      else
        {:error, %{reason: "unauthorized"}}
      end
    end
    ```

5. And then add a `handle_info` function with the following definition:

    ```elixir
    def handle_info(:after_join, socket) do
      seats = (from s in SeatSaver.Seat, order_by: [asc: s.seat_no]) |> Repo.all
      push socket, "set_seats", %{seats: seats}
      {:noreply, socket}
    end
    ```

6. Add the following to your *web/static/js/socket.js* file anywhere above the `export default socket` line:

    ```javascript
    channel.on('set_seats', data => {
      console.log('got seats', data.seats)
    })
    ```

7. If you go to <http://localhost:4000> in your browser and open the console, you should see the following:

    ![Initial seat data in the console](/images/phoenix-elm/16.png)


### Getting seat data into Elm

1. First of all change the `init` as follows:

    ```haskell
    init : (Model, Effects Action)
    init =
      ([], Effects.none)
    ```

2. Add the following port to a signals section anywhere in the file that you like.

    ```haskell
    -- SIGNALS

    port seatLists : Signal Model
    ```

3. If you go to <http://localhost:4000> in your browser you will see the following error:

    ![port error](/images/phoenix-elm/17.png)

4. We can correct this by giving our port an initial value. In *web/static/js/app.js*

    ```javascript
    var elmDiv = document.getElementById('elm-main')
      , initialState = {seatLists: []}
      , elmApp = Elm.embed(Elm.SeatSaver, elmDiv, initialState);
    ```

5. Now if you check the browser you should see

    ![initialized port](/images/phoenix-elm/18.png)

6. To make it easier to work with, let's move our channel code through from *web/static/js/socket.js* to *web/static/js/app.js*

    ```javascript
    let channel = socket.channel("seats:planner", {})
    channel.join()
      .receive("ok", resp => { console.log("Joined successfully", resp) })
      .receive("error", resp => { console.log("Unable to join", resp) })
    ```

7. We can send our seat data to this port as follows:

    ```javascript
    channel.on('set_seats', data => {
      console.log('got seats', data.seats)
      elmApp.ports.seatLists.send(data.seats)
    })
    ```

8. Looking at the browser again we should still see no seat data. This is because we need to get the data from the port into StartApp so that it can be sent to our `update` function.

    ![still no seats](/images/phoenix-elm/18.png)

9. So let's get this data along to our `update` function. In order to pass the data into StartApp we need to put it on a Signal with values of type Action. In our Signals section add the following:

    ```haskell
    incomingActions: Signal Action
    incomingActions =
      Signal.map SetSeats seatLists
    ```

10. Now we can add this as an input to our StartApp initializer.

    ```haskell
    app =
      StartApp.start
        { init = init
        , update = update
        , view = view
        , inputs = [incomingActions]
        }
    ```

11. And then add the `SetSeats` action to the `update` function

    ```haskell
    type Action = Toggle Seat | SetSeats Model


    update : Action -> Model -> (Model, Effects Action)
    update action model =
      case action of
        Toggle seatToToggle ->
          ...
        SetSeats seats ->
          (seats, Effects.none)
    ```

12. Checking the browser you should now see all of the seat data passed through.

    ![yay seat data](/images/phoenix-elm/19.png)

## Summary

We're now fetching the initial seat data using channels rather than HTTP request/response. In part 12, which should be out soon, we'll deal with toggling a seat from available to occupied (and vice versa) over channels.

We'll be announcing the rest of the tutorial on Twitter ([@cultivatehq](https://twitter.com/cultivatehq) using hashtag [#phoenixelm](https://twitter.com/hashtag/phoenixelm?src=hash)), so keep an eye out for updates!

